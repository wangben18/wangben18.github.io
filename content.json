{"posts":[{"title":"深入浅出图解 KMP 算法思想","text":"维基百科介绍 在计算机科学中，Knuth-Morris-Pratt字符串查找算法（简称为KMP算法）可在一个字符串S内查找一个词W的出现位置。一个词在不匹配时本身就包含足够的信息来确定下一个匹配可能的开始位置，此算法利用这一特性以避免重新检查先前配对的字符。这个算法由高德纳和沃恩·普拉特在1974年构思，同年詹姆斯·H·莫里斯也独立地设计出该算法，最终三人于1977年联合发表。 核心思想利用最长相等前后缀跳过相等字符，避免多余计算 核心步骤 计算模式串的最长相等前后缀数组（next 数组） 利用 next 数组在匹配字符串时跳过相等的字符，直到匹配结束 图解 Go 代码1234567891011121314151617181920212223242526272829303132333435363738package problemsfunc strStr(haystack string, needle string) int { if len(needle) == 0 || len(haystack) == 0 { return -1 } j := 0 next := getNext(needle) for i := 0; i &lt; len(haystack); i++ { for j &gt; 0 &amp;&amp; haystack[i] != needle[j] { j = next[j-1] } if haystack[i] == needle[j] { j++ } if j == len(needle) { return i - len(needle) + 1 } } return -1}func getNext(s string) []int { j := 0 next := make([]int, len(s)) next[0] = 0 for i := 1; i &lt; len(s); i++ { for j &gt; 0 &amp;&amp; s[j] != s[i] { j = next[j-1] } if s[j] == s[i] { j++ } next[i] = j } return next} 测试用例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package problemsimport ( &quot;reflect&quot; &quot;testing&quot;)func Test_getNext(t *testing.T) { type args struct { s string } tests := []struct { name string args args want []int }{ { name: &quot;&quot;, args: args{ s: &quot;benbenw&quot;, }, want: []int{0, 0, 0, 1, 2, 3, 0}, }, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { if got := getNext(tt.args.s); !reflect.DeepEqual(got, tt.want) { t.Errorf(&quot;getNext() = %v, want %v&quot;, got, tt.want) } }) }}func Test_strStr(t *testing.T) { type args struct { haystack string needle string } tests := []struct { name string args args want int }{ { name: &quot;&quot;, args: args{ haystack: &quot;benbenbenw&quot;, needle: &quot;benbenw&quot;, }, want: 3, }, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { if got := strStr(tt.args.haystack, tt.args.needle); got != tt.want { t.Errorf(&quot;strStr() = %v, want %v&quot;, got, tt.want) } }) }} 力扣相关题目力扣 28 题：找出字符串中第一个匹配项的下标力扣 459 题：重复的子字符串","link":"/2023/09/25/KMP/"},{"title":"LRU 缓存","text":"背景内存空间是有限的，当数据量超过空间的时候就得考虑淘汰哪部分数据，那按什么规则淘汰呢？ 把最久没用到的数据淘汰了不就行了，最久没用的数据直觉上不就是不太会被访问的数据吗，既然不会被访问，那就先淘汰呗，LRU 算法就是这么来的 LRU（Least Recently Used）按字面意思理解就是最近最少使用，那该怎么知道哪个数据是最近最少使用的呢？ LRU 的数据结构用链表实现！用链表是个很自然就可以想到的办法。每次数据块在存取完后将其重新排到头节点上，这样当数据在头节点说明它最近才被使用过 数据块在尾节点说明它是最久没被用到的，当数据超出内存限制时将尾节点的数据块删掉就行了 但链表有个缺点就是链表查询、更新、删除操作的时间复杂度都是 O(n)，只有在头尾新增数据时才是 O(1)，要是能把 O(n) 复杂度都降到 O(1) 岂不妙哉？ 用哈希表呀！哈希表查询数据的复杂度不就是 O(1) 嘛！ 那我们该怎么把哈希表用进去呢？ 首先数据在查询时肯定需要从哈希表查，这样才能发挥出哈希表查得快的作用 其次要把数据被使用的信息体现到链表里（也就是把刚用过的数据提到头节点），这样才可以在数据溢出时知道去淘汰哪个 话不多说，3，2，1，上代码！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package problemstype LRUCache struct { LinkedList *DoubleLinkedList LinkedNodeMap map[int]*DoubleLinkedNode capacity int}func Constructor(capacity int) LRUCache { if capacity == 0 { panic(&quot;capacity should not be zero&quot;) } return LRUCache{ LinkedList: ConstructDoubleLinkedList(), LinkedNodeMap: map[int]*DoubleLinkedNode{}, capacity: capacity, }}func (cache *LRUCache) Get(key int) int { node, ok := cache.LinkedNodeMap[key] if !ok { return -1 } cache.LinkedList.MoveToTop(node) return node.Value.(CacheNode).Value}func (cache *LRUCache) Put(key int, value int) { newCacheNode := CacheNode{key, value} node, ok := cache.LinkedNodeMap[key] if ok { node.Value = newCacheNode cache.LinkedList.MoveToTop(node) return } if len(cache.LinkedNodeMap) == cache.capacity { delete(cache.LinkedNodeMap, cache.LinkedList.Tail.Pre.Value.(CacheNode).Key) cache.LinkedList.Remove(cache.LinkedList.Tail.Pre) } newLinkedNode := &amp;DoubleLinkedNode{Value: newCacheNode} cache.LinkedNodeMap[key] = newLinkedNode cache.LinkedList.AddToTop(newLinkedNode)}type DoubleLinkedList struct { Head *DoubleLinkedNode Tail *DoubleLinkedNode}func ConstructDoubleLinkedList() *DoubleLinkedList { tail := &amp;DoubleLinkedNode{} head := &amp;DoubleLinkedNode{} tail.Pre = head head.Next = tail return &amp;DoubleLinkedList{ Head: head, Tail: tail, }}func (list *DoubleLinkedList) MoveToTop(node *DoubleLinkedNode) { list.Remove(node) list.AddToTop(node)}func (list *DoubleLinkedList) Remove(node *DoubleLinkedNode) { node.Pre.Next = node.Next node.Next.Pre = node.Pre}func (list *DoubleLinkedList) AddToTop(node *DoubleLinkedNode) { list.Head.Next.Pre = node node.Next = list.Head.Next node.Pre = list.Head list.Head.Next = node}type CacheNode struct { Key int Value int} I have a 链表～, I have a 哈希表～, 嗯！？LRU Cache ！ 怎么样，是不是很好玩呀","link":"/2023/09/26/LRU/"},{"title":"删除启动台 (Launchpad) 中无法去除的图标","text":"应用删除后图标还在启动台？打开终端！ 找到 Launchpad 存放数据的路径 1find 2&gt;/dev/null /private/var/folders -name com.apple.dock.launchpad 进入输出目录的db子目录 1cd /private/var/folders/**/com.apple.dock.launchpad/db 删除数据库中title为@@@的数据，将@@@替换为应用名称（区分大小写）&amp;&amp;重启Dock 1sqlite3 db &quot;delete from apps where title='@@@';&quot;&amp;&amp;killall Dock","link":"/2019/10/13/delete-from-launchpad/"},{"title":"Go map","text":"哈希表哈希表的查询效率贼高，时间复杂度是 O(1)，这是咋实现的呢？ Go 的哈希表结构就是 map，这次我们就来探索一下它底层是咋回事～ 3，2，1，上源码！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const ( // Maximum number of key/value pairs a bucket can hold. bucketCntBits = 3 bucketCnt = 1 &lt;&lt; bucketCntBits)// A header for a Go map.type hmap struct { // Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go. // Make sure this stays in sync with the compiler's definition. count int // # live cells == size of map. Must be first (used by len() builtin) flags uint8 B uint8 // log_2 of # of buckets (can hold up to loadFactor * 2^B items) noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details hash0 uint32 // hash seed buckets unsafe.Pointer // array of 2^B Buckets. may be nil if count==0. oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing nevacuate uintptr // progress counter for evacuation (buckets less than this have been evacuated) extra *mapextra // optional fields}// mapextra holds fields that are not present on all maps.type mapextra struct { // If both key and elem do not contain pointers and are inline, then we mark bucket // type as containing no pointers. This avoids scanning such maps. // However, bmap.overflow is a pointer. In order to keep overflow buckets // alive, we store pointers to all overflow buckets in hmap.extra.overflow and hmap.extra.oldoverflow. // overflow and oldoverflow are only used if key and elem do not contain pointers. // overflow contains overflow buckets for hmap.buckets. // oldoverflow contains overflow buckets for hmap.oldbuckets. // The indirection allows to store a pointer to the slice in hiter. overflow *[]*bmap oldoverflow *[]*bmap // nextOverflow holds a pointer to a free overflow bucket. nextOverflow *bmap}// A bucket for a Go map.type bmap struct { // tophash generally contains the top byte of the hash value // for each key in this bucket. If tophash[0] &lt; minTopHash, // tophash[0] is a bucket evacuation state instead. tophash [bucketCnt]uint8 // Followed by bucketCnt keys and then bucketCnt elems. // NOTE: packing all the keys together and then all the elems together makes the // code a bit more complicated than alternating key/elem/key/elem/... but it allows // us to eliminate padding which would be needed for, e.g., map[int64]int8. // Followed by an overflow pointer.} 这个就是 Go map 底层结构的部分源码了，业务代码中的每一个 map 底层对应的就是一个 hmap 咋？一下子给的太多受不了？没事，咱一个个来看！ 先看 hmaphmap 有个字段 buckets，这个字段的结构是一个指针，指向了一个数组，这个数组里的元素是啥呢？ bmap其实就是上面源码中的 bmap 结构，这个 bmap 里放的就是你存进 map 里的 key value 了，每个 bmap 里都可以保存 bucketCnt 个键值对 啥？你说这个 bmap 里不就一个 tophash 字段，哪有什么 key value？ bmap 里 key value 在哪3，2，1 上源码！ 123k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))v := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize)) key value 就是这么通过指针计算获取的，key value 数据就存在 tophash 的后边 怎么知道数据放在哪个 bmap，难道是按顺序放吗不是哦！按顺序一个个查过去和直接用数组有啥区别。。。 这时候就要说到 hash 值了 1hash := alg.hash(key, uintptr(h.hash0)) Go 就是用 hmap.hash0 和你存进 map 的 key 进行哈希运算，相等的 key 每次运算得出的 hash 值也相等 这个 hash 值可太有用了，map 就是用这个才实现出 O(1) 的时间复杂度 hash 值咋用再看下一段源码，这段源码是 map 在决定数据放到哪个 bmap 时用的 1bucket := hash &amp; bucketMask(h.B) 好家伙，用 hash 值和一个玩意做了个与运算 bucketMask(h.B) 是啥先看下 bucketMask 是啥 1234// bucketMask returns 1&lt;&lt;b - 1, optimized for code generation.func bucketMask(b uint8) uintptr { return bucketShift(b) - 1} ok，bucketMask 做的操作就是把 1 按二进制左移 b 位后再减去 1，比如当传进来的 b 是 4，1 用二进制表示是 0b1，左移 4 位后就是 0b10000，再减去 1 就是 0b1111 h.B 是啥h.B 就是 hmap 里的 B 字段，记录了 buckets 数组的长度信息 hmap.buckets 数组的长度是 2 的 hmap.B 次方，如果 B 是 4，那么 buckets 数组的长度是 2 的 4 次方就是 16 做 &amp; 运算有啥意义现在我们已经知道 hash 是哈希运算得出的值，类型为 uintptr，他在 64 位机器上是 64 个 0 和 1 组成的 bucketMask(h.B) 是掩码，返回值类型也是 uintptr 好了，看到这里已经知道 map 基本的数据存取是咋做的了。 但是如果数据越来越多，现有的 bmap 放不下了该怎么办？ 这就得讲 map 的扩容了 扩容到这写得有点累了，下回再更新，抱一丝～","link":"/2023/09/27/go-map/"},{"title":"Nginx 站点设置入门教程","text":"Nginx是一个快速且强大的http和反向代理服务器，能够快捷方便地提供服务 安装假设运行的系统是Ubuntu，在terminal输入如下命令安装nginx 1apt-get install nginx 此时用浏览器访问你服务器的IP地址，你将会看见“welcome to nginx”页面 nginx的位置所有nginx的配置文件都在**/etc/nginx目录下，cd到这个目录。本次教程要添加的配置文件会放在其中一个名为sites-enabled目录下，cd到该目录里，你会发现有个default文件在里面，就是这个文件使你看见“welcome to nginx”。touch一个test**在该目录下并用你喜欢的编辑器打开 设置静态服务器Nginx的config文件有它自己的一套与css的类似的语法规则。如下是一个名为server的一级命名空间 123server {} 在这个命名空间内部，可以像css那样添加以分号结尾的键值对，也可以再添加一块子命名空间 键值对（key-value pairs）也称为指令（directives），命令有很多很多，本教程只用到其中一小部分，下面每个命令都加了一个指向该命令文档的链接，想要了解更多就看文档吧，文档是唯一的官方了解途径。如果你想要更加复杂高级的设置，也免不了要看文档。 listen指令用来设置服务器监听的端口号，默认为80 123server { listen 80;} 由于80是默认值，可以不用写该指令，但为了表示清楚，写上也是极好的 server_name指令用来匹配url。如果你的站点在https://wongben.com，那根server_name就是wongben.com。如果还有一个在https://abc.com，可以再添加一个abc.com的server_name，各自的请求就会匹配到各自的站点里。 1234server { listen 80; server_name wongben.com;} root指令是设置静态网页的关键组成部分。如果你只是想要发布一些html和css文件，root指令描述了这些文件的存放位置。现在，创建目录 /var/www/example（也可以是其他任意位置），在此目录下，touch index.html，编辑该文件，存入一些类似hello world的文字，保存。回到刚才的配置文件，添加root指令 12345server { listen 80; server_name wongben.com; root /var/www/example;} location指令有两个参数：1.字符串或正则 2.一个block（即命名空间namespace）。如果你想要给 wongben.com/whatever 指定页面，就用’whatever’作为uri。在这里，我们要匹配的是根目录，所以使用 / 作为uri 123456789server { listen 80; server_name wongben.com; root /var/www/example; location / { }} “**/**” 会匹配所有url，因为它被看成是一个正则。如果你想要单独匹配字符串，就加个等号 1location = / { ... } try_files指令根据文件名列表或模式在root指定的目录下寻找匹配的文件，在这里我们要做的很简单，匹配任何斜杠之后的字符，例如’whatever.html’，要是斜杠后没有任何字符，则匹配index.html。 123456789server { listen 80; server_name wongben.com; root /var/www/example; location / { try_files $uri $uri/ /index.html; }} 发布运行如下命令让nginx重新载入 1service nginx reload 然后就可以在浏览器输入地址访问服务器啦 English","link":"/2019/02/25/nginx-tutorial/"},{"title":"图解快速排序","text":"维基百科介绍 快速排序（英语：Quicksort），又称分区交换排序（partition-exchange sort），是一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序 n 个项目要 O(nlogn) 次比较。在最坏状况下则需要 O(n2) 次比较，但这种状况并不常见。事实上，快速排序 Θ(nlog⁡n) 通常明显比其他算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地达成。 核心步骤 选择基准：选择待排序数组中的一个数字作为基准 按基准分组：遍历数组元素，将小于基准值的数字移动到基准值左侧，大于的则移到右侧 递归：在基准值左侧与右侧数组重复 1、2、3 步，直到所有数据排序完成 核心步骤图解 C 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;void EXCHANGE(int *left, int *right){ if (left == right) return; *left ^= *right; *right ^= *left; *left ^= *right;}int PARTITION(int A[], int left, int right){ int pivotValue = A[right]; int pivotDest = left; for (int i = left; i &lt; right; i++) { if (A[i] &lt;= pivotValue) { EXCHANGE(&amp;A[pivotDest], &amp;A[i]); pivotDest++; } } EXCHANGE(&amp;A[pivotDest], &amp;A[right]); return pivotDest;}void QUICKSORT(int A[], int left, int right){ if (left &lt; right) { int pivot = PARTITION(A, left, right); QUICKSORT(A, left, pivot - 1); QUICKSORT(A, pivot + 1, right); }}int main(int argc, char const *argv[]){ int A[] = {7, 3, 9, 5, 8, 4, 2}; QUICKSORT(A, 0, 7); for (int i = 0; i &lt;= 7; i++) { printf(&quot;%d &quot;, A[i]); } printf(&quot;\\n&quot;); return 0;} Go 代码1234567891011121314151617181920212223242526272829303132package sortfunc QuickSort(a []int) []int { partition := func(a []int, lo, hi int) int { i, j := lo+1, hi for { for ; i &lt; hi &amp;&amp; a[i] &lt;= a[lo]; i++ { } for ; j &gt; lo &amp;&amp; a[j] &gt;= a[lo]; j-- { } if j &lt;= i { break } a[i], a[j] = a[j], a[i] } a[i-1], a[lo] = a[lo], a[i-1] return i - 1 } var sort func(a []int, lo, hi int) sort = func(a []int, lo, hi int) { if lo &gt;= hi { return } j := partition(a, lo, hi) sort(a, lo, j-1) sort(a, j+1, hi) } sort(a, 0, len(a)-1) return a} 改进数组偏小时改用插入排序 1234if lo+M &gt;= hi { InsertionSort(a, lo, hi) return}","link":"/2023/09/25/quicksort/"}],"tags":[{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"string","slug":"string","link":"/tags/string/"},{"name":"KMP","slug":"KMP","link":"/tags/KMP/"},{"name":"data structure","slug":"data-structure","link":"/tags/data-structure/"},{"name":"cache","slug":"cache","link":"/tags/cache/"},{"name":"lru","slug":"lru","link":"/tags/lru/"},{"name":"mac","slug":"mac","link":"/tags/mac/"},{"name":"tips","slug":"tips","link":"/tags/tips/"},{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"map","slug":"map","link":"/tags/map/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"tutorial","slug":"tutorial","link":"/tags/tutorial/"},{"name":"sort","slug":"sort","link":"/tags/sort/"},{"name":"quicksort","slug":"quicksort","link":"/tags/quicksort/"}],"categories":[{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"mac","slug":"mac","link":"/categories/mac/"},{"name":"Go","slug":"Go","link":"/categories/Go/"},{"name":"string","slug":"algorithm/string","link":"/categories/algorithm/string/"},{"name":"tutorial","slug":"tutorial","link":"/categories/tutorial/"},{"name":"data structure","slug":"algorithm/data-structure","link":"/categories/algorithm/data-structure/"},{"name":"tips","slug":"mac/tips","link":"/categories/mac/tips/"},{"name":"map","slug":"Go/map","link":"/categories/Go/map/"},{"name":"KMP","slug":"algorithm/string/KMP","link":"/categories/algorithm/string/KMP/"},{"name":"nginx","slug":"tutorial/nginx","link":"/categories/tutorial/nginx/"},{"name":"cache","slug":"algorithm/data-structure/cache","link":"/categories/algorithm/data-structure/cache/"},{"name":"lru","slug":"algorithm/data-structure/cache/lru","link":"/categories/algorithm/data-structure/cache/lru/"},{"name":"sort","slug":"algorithm/sort","link":"/categories/algorithm/sort/"},{"name":"quicksort","slug":"algorithm/sort/quicksort","link":"/categories/algorithm/sort/quicksort/"}],"pages":[]}